//
// This file is part of the GNU ARM Eclipse Plug-ins project.
// Copyright (c) 2014 Liviu Ionescu.
//

// ----------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>

#include "diag/Trace.h"
#include "Timer.h"

// ----------------------------------------------------------------------------
//
// Print a greeting message on the trace device and enter a loop
// to count seconds.
//
// Trace support is enabled by adding the TRACE macro definition.
// By default the trace messages are forwarded to the DEBUG output,
// but can be rerouted to any device or completely suppressed, by
// changing the definitions required in system/src/diag/trace_impl.c
// (currently OS_USE_TRACE_ITM, OS_USE_TRACE_SEMIHOSTING_DEBUG/_STDOUT).
//
// ----------------------------------------------------------------------------

// Sample pragmas to cope with warnings. Please note the related line at
// the end of this function, used to pop the compiler diagnostics status.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#pragma GCC diagnostic ignored "-Wreturn-type"

//int
//main (int argc, char* argv[])
//{
//  // Normally at this stage most of the microcontroller subsystems, including
//  // the clock, were initialised by the CMSIS SystemInit() function invoked
//  // from the startup file, before calling main().
//  // (see system/src/cortexm/_initialize_hardware.c)
//  // If further initialisations are required, customise __initialize_hardware()
//  // or add the additional initialisation here, for example:
//  //
//  // HAL_Init();
//
//  // In this sample the SystemInit() function is just a placeholder,
//  // if you do not add the real one, the clock will remain configured with
//  // the reset value, usually a relatively low speed RC clock (8-12MHz).
//
//  // Send a greeting to the trace device (skipped on Release).
//  trace_puts("Hello ARM World!");
//
//  // At this stage the system clock should have already been configured
//  // at high speed.
//  trace_printf("System clock: %u Hz\n", SystemCoreClock);
//
//  timer_start ();
//
//  int seconds = 0;
//
//  // Infinite loop
//  while (1)
//    {
//      timer_sleep (TIMER_FREQUENCY_HZ);
//
//      ++seconds;
//
//      // Count seconds on the trace device.
//      trace_printf ("Second %d\n", seconds);
//    }
//  // Infinite loop, never return.
//}

#include ¨lwip/sockets.h¨

#define SENDER_PORT_NUM 6000
#define SENDER_IP_ADDR "192.136.23.20"

#define SERVER_PORT_NUM 6001
#define SERVER_IP_ADDRESS "192.136.23.21"


int main(void)
{

	int socket_fd;
	struct sockaddr_in sa,ra;
	int recv_data; char data_buffer[80];

	/* Creates an TCP socket (SOCK_STREAM) with Internet Protocol Family (PF_INET).
	 * Protocol family and Address family related. For example PF_INET Protocol Family and AF_INET family are coupled.
	*/
	socket_fd = socket(PF_INET, SOCK_STREAM, 0);
	if ( socket_fd < 0 )
	{
		printf("socket call failed");
		exit(0);
	}

	memset(&sa, 0, sizeof(struct sockaddr_in));
	sa.sin_family = AF_INET;
	sa.sin_addr.s_addr = inet_addr(SENDER_IP_ADDR);
	sa.sin_port = htons(SENDER_PORT_NUM);

	/* Bind the TCP socket to the port SENDER_PORT_NUM and to the current
	* machines IP address (Its defined by SENDER_IP_ADDR).
	* Once bind is successful for UDP sockets application can operate
	* on the socket descriptor for sending or receiving data.
	*/
	if (bind(socket_fd, (struct sockaddr *)&sa, sizeof(struct sockaddr_in)) == -1)
	{
		trace_printf("Bind to Port Number %d ,IP address %s failed\n",SENDER_PORT_NUM,SENDER_IP_ADDR);
		close(socket_fd);
		exit(1);
	}

	/* Receiver connects to server ip-address. */
	memset(&ra, 0, sizeof(struct sockaddr_in));
	ra.sin_family = AF_INET;
	ra.sin_addr.s_addr = inet_addr(SERVER_IP_ADDRESS);
	ra.sin_port = htons(SERVER_PORT_NUM);
	if(connect(socket_fd,(struct sockaddr_in*)&ra,sizeof(struct sockaddr_in)) < 0)
	{
		trace_printf("connect failed \n");
		close(socket_fd);
		exit(2);
	}

	recv_data = recv(socket_fd,data_buffer,sizeof(data_buffer),0);
	if(recv_data < 0)
	{
		trace_printf("recv failed \n");
		close(socket_fd);
		exit(2);
	}

	data_buffer[recv_data] = '\0';
	trace_printf("received data: %s\n",data_buffer);

	close(socket_fd);
}
#pragma GCC diagnostic pop

// ----------------------------------------------------------------------------
