/*
 * xml.c
 *
 *  Created on: Nov 2, 2015
 *      Author: strikles
 */


#include "ezxml.h"
#include "xml.h"
#include "sensors.h"

extern Reading_t readings[max_sensors];

/**
 * builds a client xml request (update/retrieve)
 */
uint16_t buildRequestXML(eRequest req, char xml_buffer[])
{
	uint16_t ndx, error_status;
	int xml_size;
	char reading_buffer[255];

	ezxml_t request_root = ezxml_new(request_str[req]);
    if(!request_root)
    {
    	perror("Invalid request_root xml\n");
    	return 1;
    }

	// generate some random stuff
	for(ndx = 0; ndx < max_sensors; ndx++)
	{
		// test measurememt list ndx
		// test measurement type ndx

		// nothing to read
		if(readings[ndx].elapsed < readings[ndx].interval)
		{
			continue;
		}

		// reset buffer
		bzero(reading_buffer, 255);

		// Insert child_tag into root_tag
		ezxml_t child_tag = ezxml_add_child_d(request_root, sensor_str[ndx], 4);
		// text child_tag

		// copy measurement value to our char buffer
		error_status = getSensorReadingStr(ndx, reading_buffer);
        if(error_status)
        {
        	perror("Error: getSensorReadingStr\n");
        	continue;
        }

		// set the tag content
		ezxml_set_txt_d(child_tag, reading_buffer);
		// test valid return

		printf("Reading Buffer: %s\n", reading_buffer);
	}

	// get string into buffer
	char *xml = ezxml_toxml(request_root);
    if(!xml)
    {
    	perror("client generated Invalid xml\n");
    	return 1;
    }

    // test length
	xml_size = strlen(xml)+1;
	if(MAX_MSG_LEN < xml_size)
	{
		perror("client xml is too long\n");
		return 1;
	}

	bzero(xml_buffer, MAX_MSG_LEN);
	memcpy(xml_buffer, xml, xml_size);

	// free stuff
	ezxml_free(request_root);
	free(xml);

	return 0;
}
